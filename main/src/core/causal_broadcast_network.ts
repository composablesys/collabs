import { ElementSerializer } from "../util";
import { Runtime } from "./runtime";

/**
 * Interface describing the causal timestamps that
 * get passed to Crdts when they receive a message
 * (e.g., a vector clock).
 */
export interface CausalTimestamp {
  /**
   * @return The message sender's replica id.
   */
  getSender(): string;
  /**
   * @return Whether the message was generated by the local
   *  replica.  Equivalent to getSender() ===
   *  Runtime.getReplicaId().
   */
  isLocal(): boolean;
  /**
   * @return The counter for messages sent by this message's
   * sender.  Equivalent to
   * this.asVectorClock().get(this.getSender()).
   */
  getSenderCounter(): number;
  /**
   * @return This timestamp in the form of a vector clock,
   * i.e., as a map from replica ids to the number of their
   * most recent causally <= message.
   */
  asVectorClock(): Map<string, number>;

  /**
   * @return The time this message was generated, as
   * given by the sender's Date.now().  This is useful
   * in some forms of conflict resolution (e.g., a
   * last-writer-wins register).
   *
   * Note that if multiple operations
   * were sent in a single batch, then this gives the time
   * of the first operation, which may differ substantially
   * from the time of later operations.  Thus it is mostly
   * intended for conflict resolution or when batches are
   * sent relatively quickly; when batches can be long and
   * precise times are needed, Crdts should send times
   * manually.
   */
  getTime(): number;
}

/**
 * A tagged reliable causal
 * broadcast (TRCB) network.
 *
 * This network is used
 * by Runtime to broadcast messages to other
 * replicas, reliably, in causal order, and
 * tagged with causal timestamps.
 *
 * Our definition of TRCB comes from Section 5.1 of
 * [arXiv:1710.04469](http://arxiv.org/abs/1710.04469).
 * Note that unlike that paper, we do not consider causal
 * stability, hence why we use TRCB instead of their Tagged
 * Causal Stable Broadcast.
 *
 * We recommend using [[DefaultCausalBroadcastNetwork]], which
 * allows you to customize the underlying network without
 * handling causality yourself.
 */
export interface CausalBroadcastNetwork
  extends ElementSerializer<CausalTimestamp> {
  /**
   * Called by the using Runtime.
   */
  registerRuntime(
    runtime: Runtime,
    onreceive: (
      message: Uint8Array,
      firstTimestamp: CausalTimestamp
    ) => CausalTimestamp,
    onreceiveblocked: (sender: string) => void
  ): void;

  /**
   * Returns the timestamp for the next message sent by previous' sender
   * after a message with the timestamp `previous`.  This should not
   * change the internal state---it is not guaranteed that this timestamp
   * will be used/received, in case processing its message fails.
   * @param previous
   * @return
   */
  nextTimestamp(previous: CausalTimestamp): CausalTimestamp;

  /**
   * Begins a new batch and return its first timestamp.
   *
   * During a batch, don't deliver any messages to the runtime.
   * @return       [description]
   */
  beginBatch(): CausalTimestamp;

  /**
   * Commits a batch, sending its message to the network.
   *
   * @param message        The message to send.
   * @param firstTimestamp The timestamp of the first message
   * in the batch, i.e., the timestamp returned by beginBatch().
   * @param lastTimestamp  The timestamp of the last message
   * in the batch.
   */
  commitBatch(
    message: Uint8Array,
    firstTimestamp: CausalTimestamp,
    lastTimestamp: CausalTimestamp
  ): void;

  /**
   * Saves this CausalBroadcastNetwork in serialized form.  This method should
   * only be called by [[Runtime.save]].
   *
   * The returned `saveData` may later be passed to [[load]]
   * on a newly initialized instance of the same class,
   * constructed with the same constructor arguments.
   * The loaded instance will then deliver to the runtime
   * precisely any messages that were not delivered before
   * saving, in causal order as usual.
   *
   * save cannot be called when a batch is in progress (between
   * [[beginBatch]] and [[commitBatch]]).
   *
   * Advice for implementers:
   * - The save data should include
   * your current position in
   * the causal order, plus any queued messages.
   * - Note that
   * [[load]] will be called on a replica
   * with a different replicaId than this one, and that
   * the save data may be loaded by multiple replicas concurrently.  Thus
   * the save data must be forkable without breaking causal
   * ordering.
   *
   * @return `saveData`
   */
  save(): Uint8Array;

  /**
   * Loads the state from save data.  See [[save]].  This method should
   * only be called by [[Runtime.load]].
   *
   * This must have been constructed with the same class and
   * constructor arguments as the saved instance, and it must
   * not have sent or received any messages yet.
   *
   * @param saveData An output of [[save]] from a previous
   * instance of this class. Note that `saveData` will have been output
   * by a different replica (with a different [[Runtime.replicaId]]),
   * and the same `saveData` may be loaded on multiple
   * replicas, possibly concurrently.
   */
  load(saveData: Uint8Array): void;

  /** Used for type guard. */
  readonly isCausalBroadcastNetwork: true;
}

/**
 * @return whether network is an instance of [[CausalBroadcastNetwork]]
 */
export function isCausalBroadcastNetwork(
  network: any
): network is CausalBroadcastNetwork {
  return network.isCausalBroadcastNetwork === true;
}
