// First attempt at the interface between the runtime
// (causal broadcast network, etc.) and the Crdts.

import { Runtime } from "../crdt";

/**
 * Interface describing the causal timestamps that
 * get passed to Crdts when they receive a message
 * (e.g., a vector clock).
 * TODO: have a stripped-down interface plus a wrapper around it
 * that computes isLocal().
 */
export interface CausalTimestamp {
  /**
   * @return the message sender's replica id.
   */
  getSender(): string;
  /**
   * @return whether the message was generated by the local
   *  replica.  Must be equivalent to getSender() ===
   *  Runtime.getReplicaId().
   */
  isLocal(): boolean;
  /**
   * @return the counter for messages sent by this message's
   * sender.  It must be the same as
   * this.asVectorClock().get(this.getSender()).
   */
  getSenderCounter(): number;
  /**
   * @return this timestamp in the form of a vector clock,
   * i.e., as a map from replica ids to the number of their
   * most recent <= message.
   */
  asVectorClock(): Map<string, number>;

  /**
   * @return the time this message was generated, as
   * given by the sender's Date.now().  This is useful
   * in some forms of conflict resolution (e.g., a
   * last-writer-wins register).
   *
   * Note that if multiple operations
   * were sent in a single batch, then this gives the time
   * of the first operation, which may differ substantially
   * from the time of later operations.  Thus it is mostly
   * intended for conflict resolution or when batches are
   * sent relatively quickly; when batches can be long and
   * precise times are needed, Crdts should send times
   * manually.
   */
  getTime(): number;
}

/**
 * Interface describing a (tagged reliable) causal
 * broadcast (TRCB) network.  This network is used
 * by Runtime to broadcast messages to other
 * replicas, reliably, in causal order, and
 * tagged with causal timestamps.
 */
export interface CausalBroadcastNetwork {
  /**
   * Registers the given Runtime to receive messages
   * from other replicas.  Such messages should be delivered
   * to crdtRuntime.receive.  This method will be
   * called exactly once, before any other methods.
   * @param crdtRuntime The Runtime.
   */
  register(crdtRuntime: Runtime): void;

  /**
   * Return the timestamp for the next message sent by previous' sender
   * after a message with the given timestamp.  This should not
   * change the internal state---it is not guaranteed that this timestamp
   * will be used/received, in case processing its message fails.
   * @param previous [description]
   * @return         [description]
   */
  nextTimestamp(previous: CausalTimestamp): CausalTimestamp;

  /**
   * TODO: batching.  During a batch, don't deliver any messages for
   * that group to the Runtime.
   * @param  group [description]
   * @return       [description]
   */
  beginBatch(): CausalTimestamp;
  commitBatch(
    message: Uint8Array,
    firstTimestamp: CausalTimestamp,
    lastTimestamp: CausalTimestamp
  ): void;

  /** Used for type guard. */
  readonly isCausalBroadcastNetwork: true;
}

export function isCausalBroadcastNetwork(
  network: any
): network is CausalBroadcastNetwork {
  return network.isCausalBroadcastNetwork === true;
}
