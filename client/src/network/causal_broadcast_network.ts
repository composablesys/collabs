// First attempt at the interface between the runtime
// (causal broadcast network, etc.) and the Crdts.

import { CrdtRuntime } from "../crdts";

/**
 * Interface describing the causal timestamps that
 * get passed to Crdts when they receive a message
 * (e.g., a vector clock).
 * TODO: have a stripped-down interface plus a wrapper around it
 * that computes isLocal().
 */
export interface CausalTimestamp {
  /**
   * @return the message sender's replica id.
   */
  getSender(): string;
  /**
   * @return whether the message was generated by the local
   *  replica.  Must be equivalent to getSender() ===
   *  CrdtRuntime.getReplicaId().
   */
  isLocal(): boolean;
  /**
   * @return the counter for messages sent by this message's
   * sender.  It must be the same as
   * this.asVectorClock().get(this.getSender()).
   */
  getSenderCounter(): number;
  /**
   * @return this timestamp in the form of a vector clock,
   * i.e., as a map from replica ids to the number of their
   * most recent <= message.
   */
  asVectorClock(): Map<string, number>;
  // TODO: ?
}

/**
 * Interface describing a (tagged reliable) causal
 * broadcast (TRCB) network.  This network is used
 * by CrdtRuntime to broadcast messages to other
 * replicas, reliably, in causal order, and
 * tagged with causal timestamps.
 */
export interface CausalBroadcastNetwork {
  /**
   * Registers the given CrdtRuntime to receive messages
   * from other replicas.  Such messages should be delivered
   * to crdtRuntime.receive.  This method will be
   * called exactly once, before any other methods.
   * @param crdtRuntime The CrdtRuntime.
   */
  register(crdtRuntime: CrdtRuntime): void;
  /**
   * Called by CrdtRuntime when it is instructed
   * (TODO: how/where) to join the given group.
   * When joinGroup(group) is called, this should
   * asynchronously (i.e., not within this method call,
   * but later)
   * deliver all prior messages intended for group
   * to the CrdtRuntime (as if they had been sent just
   * now in causal order),
   * including messages sent by this replica in
   * previous sessions.  (TODO: make sure that plays nicely
   * with local ops; or perhaps mandate that replica ids
   * are unique for each session?  That would also help with
   * if the same user connects multiple times at once).
   * (TODO: where to deliver errors)
   * if there is a problem joining the group, e.g., it
   * does not exist or this replica does not have permission
   * to access it.
   * @param group A "group"
   * encompasses both a set of replicas (in a way
   * specific to your application, e.g., they could be
   * UIDs for group chats or documents on your server)
   * and a unit
   * of causal consistency, i.e., messages should
   * be causally consistent within a group but need
   * not be across groups.  (TODO: separate out these
   * concerns?  Perhaps have "document" vs "causalGroup").
   */
  joinGroup(group: string): void;

  /**
   * Return the timestamp for the next message sent by previous' sender
   * after a message with the given timestamp.  This should not
   * change the internal state---it is not guaranteed that this timestamp
   * will be used/received, in case processing its message fails.
   * @param previous [description]
   * @return         [description]
   */
  nextTimestamp(previous: CausalTimestamp): CausalTimestamp;

  /**
   * TODO: batching.  During a batch, don't deliver any messages for
   * that group to the CrdtRuntime.
   * @param  group [description]
   * @return       [description]
   */
  beginBatch(group: string): CausalTimestamp;
  commitBatch(
    group: string,
    message: Uint8Array,
    firstTimestamp: CausalTimestamp,
    lastTimestamp: CausalTimestamp
  ): void;
}
